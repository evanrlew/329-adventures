
Project2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008a  00800100  0000066a  000006fe  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000066a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000007  0080018a  0080018a  00000788  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  00000788  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  00000e54  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00000ee0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00000962  00000000  00000000  00000fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000278  00000000  00000000  00001902  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000530  00000000  00000000  00001b7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000294  00000000  00000000  000020ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000002e3  00000000  00000000  00002340  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000526  00000000  00000000  00002623  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
   4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
   c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  28:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  2c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  30:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  44:	0c 94 33 02 	jmp	0x466	; 0x466 <__vector_17>
  48:	0c 94 5b 02 	jmp	0x4b6	; 0x4b6 <__vector_18>
  4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  54:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  58:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  5c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  60:	0c 94 0d 02 	jmp	0x41a	; 0x41a <__vector_24>
  64:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  78:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  80:	0c 94 83 02 	jmp	0x506	; 0x506 <__vector_32>
  84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  8c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  90:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  94:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  98:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  9c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
  a8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

000000ac <__ctors_end>:
  ac:	11 24       	eor	r1, r1
  ae:	1f be       	out	0x3f, r1	; 63
  b0:	cf ef       	ldi	r28, 0xFF	; 255
  b2:	da e0       	ldi	r29, 0x0A	; 10
  b4:	de bf       	out	0x3e, r29	; 62
  b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
  b8:	11 e0       	ldi	r17, 0x01	; 1
  ba:	a0 e0       	ldi	r26, 0x00	; 0
  bc:	b1 e0       	ldi	r27, 0x01	; 1
  be:	ea e6       	ldi	r30, 0x6A	; 106
  c0:	f6 e0       	ldi	r31, 0x06	; 6
  c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
  c4:	05 90       	lpm	r0, Z+
  c6:	0d 92       	st	X+, r0
  c8:	aa 38       	cpi	r26, 0x8A	; 138
  ca:	b1 07       	cpc	r27, r17
  cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
  ce:	11 e0       	ldi	r17, 0x01	; 1
  d0:	aa e8       	ldi	r26, 0x8A	; 138
  d2:	b1 e0       	ldi	r27, 0x01	; 1
  d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
  d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
  d8:	a1 39       	cpi	r26, 0x91	; 145
  da:	b1 07       	cpc	r27, r17
  dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
  de:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <main>
  e2:	0c 94 33 03 	jmp	0x666	; 0x666 <_exit>

000000e6 <__bad_interrupt>:
  e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <initButtons>:
	}
	return 0;
}  // end main

void initButtons(void) {
	DDRD &= ~(1<<WAVE_TYPE_BTN | 1<<FREQ_VAL_BTN);
  ea:	8a b1       	in	r24, 0x0a	; 10
  ec:	8c 7f       	andi	r24, 0xFC	; 252
  ee:	8a b9       	out	0x0a, r24	; 10
	PORTD |= 1<<WAVE_TYPE_BTN | 1<<FREQ_VAL_BTN;
  f0:	8b b1       	in	r24, 0x0b	; 11
  f2:	83 60       	ori	r24, 0x03	; 3
  f4:	8b b9       	out	0x0b, r24	; 11
	DDRF &= ~(1<<DUTY_CYCLE_BTN);
  f6:	84 98       	cbi	0x10, 4	; 16
	PORTF |= 1<<DUTY_CYCLE_BTN;
  f8:	8c 9a       	sbi	0x11, 4	; 17
}
  fa:	08 95       	ret

000000fc <initTimer1>:
	set_wave();
}

void initTimer1(void)
{
	TCCR1A = 0x00;                          // configure counter wave mode and compare mode
  fc:	10 92 80 00 	sts	0x0080, r1
	TCCR1B = (1<<WGM12);								// clock off initially
 100:	88 e0       	ldi	r24, 0x08	; 8
 102:	80 93 81 00 	sts	0x0081, r24
	//OCR1AH = 0x01;                          // compare reg a = 500
	//OCR1AL = 0xF4;
	//OCR1BH = 0x00;                          // compare reg b = 125
	//OCR1BL = 0x7D;	
	TIMSK1 = (1<<ICIE1)|(1<<OCIE1A)|(1<<OCIE1B); // enable interupts for a and b
 106:	86 e2       	ldi	r24, 0x26	; 38
 108:	80 93 6f 00 	sts	0x006F, r24
	TIFR1 = 0x00;
 10c:	16 ba       	out	0x16, r1	; 22
}
 10e:	08 95       	ret

00000110 <initTimer3>:

void initTimer3(void)
{
	TCCR3A = 0x00;                          // configure counter wave mode and compare mode
 110:	10 92 90 00 	sts	0x0090, r1
	TCCR3B = (1<<WGM32);          // clock off , wave mode
 114:	88 e0       	ldi	r24, 0x08	; 8
 116:	80 93 91 00 	sts	0x0091, r24
	TIMSK3 = (1<<ICIE3)|(1<<OCIE3A); // enable interupts for a and b
 11a:	82 e2       	ldi	r24, 0x22	; 34
 11c:	80 93 71 00 	sts	0x0071, r24
	TIFR3 = 0x00;
 120:	18 ba       	out	0x18, r1	; 24
}
 122:	08 95       	ret

00000124 <timer1_on>:

void timer1_on(void) {
	TCCR1B |= (1<<CS11)|(1<<CS10); // clock prescale 1/64, wave mode
 124:	e1 e8       	ldi	r30, 0x81	; 129
 126:	f0 e0       	ldi	r31, 0x00	; 0
 128:	80 81       	ld	r24, Z
 12a:	83 60       	ori	r24, 0x03	; 3
 12c:	80 83       	st	Z, r24
	TIMSK1 = (1<<ICIE1)|(1<<OCIE1A)|(1<<OCIE1B);
 12e:	86 e2       	ldi	r24, 0x26	; 38
 130:	80 93 6f 00 	sts	0x006F, r24
}
 134:	08 95       	ret

00000136 <timer1_off>:

void timer1_off(void) {
	TCCR1B &= ~(1 << CS10 | 1 << CS11 | 1 << CS12);
 136:	e1 e8       	ldi	r30, 0x81	; 129
 138:	f0 e0       	ldi	r31, 0x00	; 0
 13a:	80 81       	ld	r24, Z
 13c:	88 7f       	andi	r24, 0xF8	; 248
 13e:	80 83       	st	Z, r24
	TIMSK1 = 0;
 140:	10 92 6f 00 	sts	0x006F, r1
}
 144:	08 95       	ret

00000146 <timer3_on>:

void timer3_on(void) {
	TCCR3B |= (1<<CS30);          // clock no prescale
 146:	e1 e9       	ldi	r30, 0x91	; 145
 148:	f0 e0       	ldi	r31, 0x00	; 0
 14a:	80 81       	ld	r24, Z
 14c:	81 60       	ori	r24, 0x01	; 1
 14e:	80 83       	st	Z, r24
	TIMSK3 = (1<<ICIE3)|(1<<OCIE3A);
 150:	82 e2       	ldi	r24, 0x22	; 34
 152:	80 93 71 00 	sts	0x0071, r24
}	
 156:	08 95       	ret

00000158 <timer3_off>:
	
void timer3_off(void) {
	TCCR3B &= ~(1 << CS30);
 158:	e1 e9       	ldi	r30, 0x91	; 145
 15a:	f0 e0       	ldi	r31, 0x00	; 0
 15c:	80 81       	ld	r24, Z
 15e:	8e 7f       	andi	r24, 0xFE	; 254
 160:	80 83       	st	Z, r24
	TIMSK3 = 0;
 162:	10 92 71 00 	sts	0x0071, r1
}
 166:	08 95       	ret

00000168 <set_wave>:

void set_wave(void) {
 168:	cf 92       	push	r12
 16a:	df 92       	push	r13
 16c:	ef 92       	push	r14
 16e:	ff 92       	push	r15
 170:	0f 93       	push	r16
 172:	1f 93       	push	r17
	uint32_t sq_ticks_per_period = F_CPU / TIMER1_PRESCALE / freq;
 174:	20 91 01 01 	lds	r18, 0x0101
 178:	30 91 02 01 	lds	r19, 0x0102
 17c:	40 91 03 01 	lds	r20, 0x0103
 180:	50 91 04 01 	lds	r21, 0x0104
 184:	60 e9       	ldi	r22, 0x90	; 144
 186:	70 ed       	ldi	r23, 0xD0	; 208
 188:	83 e0       	ldi	r24, 0x03	; 3
 18a:	90 e0       	ldi	r25, 0x00	; 0
 18c:	0e 94 11 03 	call	0x622	; 0x622 <__udivmodsi4>
 190:	69 01       	movw	r12, r18
 192:	7a 01       	movw	r14, r20
	uint32_t ticks_per_duty = sq_ticks_per_period * duty / 100;
 194:	20 91 05 01 	lds	r18, 0x0105
 198:	30 91 06 01 	lds	r19, 0x0106
 19c:	40 91 07 01 	lds	r20, 0x0107
 1a0:	50 91 08 01 	lds	r21, 0x0108
 1a4:	c7 01       	movw	r24, r14
 1a6:	b6 01       	movw	r22, r12
 1a8:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <__mulsi3>
 1ac:	24 e6       	ldi	r18, 0x64	; 100
 1ae:	30 e0       	ldi	r19, 0x00	; 0
 1b0:	40 e0       	ldi	r20, 0x00	; 0
 1b2:	50 e0       	ldi	r21, 0x00	; 0
 1b4:	0e 94 11 03 	call	0x622	; 0x622 <__udivmodsi4>
 1b8:	89 01       	movw	r16, r18
 1ba:	9a 01       	movw	r18, r20
	
	uint16_t saw_ticks_per_step;
	uint16_t sin_ticks_per_step;
	
	// calculate and set frequency
	OCR1AH = sq_ticks_per_period >> 8 & 0xFF;                          // compare reg a
 1bc:	bb 27       	eor	r27, r27
 1be:	af 2d       	mov	r26, r15
 1c0:	9e 2d       	mov	r25, r14
 1c2:	8d 2d       	mov	r24, r13
 1c4:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = sq_ticks_per_period & 0xFF;
 1c8:	c0 92 88 00 	sts	0x0088, r12
	
	// calculate and set duty
	OCR1BH = ticks_per_duty >> 8 & 0xFF;                          // compare reg b
 1cc:	bb 27       	eor	r27, r27
 1ce:	a3 2f       	mov	r26, r19
 1d0:	92 2f       	mov	r25, r18
 1d2:	81 2f       	mov	r24, r17
 1d4:	80 93 8b 00 	sts	0x008B, r24
	OCR1BL = ticks_per_duty & 0xFF;
 1d8:	00 93 8a 00 	sts	0x008A, r16

	if (fg_state == SAWTOOTH) {
 1dc:	80 91 00 01 	lds	r24, 0x0100
 1e0:	81 30       	cpi	r24, 0x01	; 1
 1e2:	99 f4       	brne	.+38     	; 0x20a <set_wave+0xa2>
		saw_ticks_per_step = F_CPU / freq / NUM_SAW_POINTS;
 1e4:	20 91 01 01 	lds	r18, 0x0101
 1e8:	30 91 02 01 	lds	r19, 0x0102
 1ec:	40 91 03 01 	lds	r20, 0x0103
 1f0:	50 91 04 01 	lds	r21, 0x0104
 1f4:	60 e9       	ldi	r22, 0x90	; 144
 1f6:	70 ed       	ldi	r23, 0xD0	; 208
 1f8:	83 e0       	ldi	r24, 0x03	; 3
 1fa:	90 e0       	ldi	r25, 0x00	; 0
 1fc:	0e 94 11 03 	call	0x622	; 0x622 <__udivmodsi4>
		OCR3AH = saw_ticks_per_step >> 8;
 200:	30 93 99 00 	sts	0x0099, r19
		OCR3AL = saw_ticks_per_step & 0xFF;
 204:	20 93 98 00 	sts	0x0098, r18
 208:	16 c0       	rjmp	.+44     	; 0x236 <set_wave+0xce>
	}	
	else if (fg_state == SINE) {
 20a:	80 91 00 01 	lds	r24, 0x0100
 20e:	82 30       	cpi	r24, 0x02	; 2
 210:	91 f4       	brne	.+36     	; 0x236 <set_wave+0xce>
		sin_ticks_per_step = F_CPU / freq / NUM_SINE_POINTS;
 212:	20 91 01 01 	lds	r18, 0x0101
 216:	30 91 02 01 	lds	r19, 0x0102
 21a:	40 91 03 01 	lds	r20, 0x0103
 21e:	50 91 04 01 	lds	r21, 0x0104
 222:	60 e9       	ldi	r22, 0x90	; 144
 224:	70 ed       	ldi	r23, 0xD0	; 208
 226:	83 e0       	ldi	r24, 0x03	; 3
 228:	90 e0       	ldi	r25, 0x00	; 0
 22a:	0e 94 11 03 	call	0x622	; 0x622 <__udivmodsi4>
		OCR3AH = sin_ticks_per_step >> 8;
 22e:	30 93 99 00 	sts	0x0099, r19
		OCR3AL = sin_ticks_per_step & 0xFF;		
 232:	20 93 98 00 	sts	0x0098, r18
	}
}
 236:	1f 91       	pop	r17
 238:	0f 91       	pop	r16
 23a:	ff 90       	pop	r15
 23c:	ef 90       	pop	r14
 23e:	df 90       	pop	r13
 240:	cf 90       	pop	r12
 242:	08 95       	ret

00000244 <change_duty>:
	}
	set_wave();
}

void change_duty(void) {
	if (duty == 90) {
 244:	80 91 05 01 	lds	r24, 0x0105
 248:	90 91 06 01 	lds	r25, 0x0106
 24c:	a0 91 07 01 	lds	r26, 0x0107
 250:	b0 91 08 01 	lds	r27, 0x0108
 254:	8a 35       	cpi	r24, 0x5A	; 90
 256:	91 05       	cpc	r25, r1
 258:	a1 05       	cpc	r26, r1
 25a:	b1 05       	cpc	r27, r1
 25c:	69 f4       	brne	.+26     	; 0x278 <change_duty+0x34>
		duty = 10;
 25e:	8a e0       	ldi	r24, 0x0A	; 10
 260:	90 e0       	ldi	r25, 0x00	; 0
 262:	a0 e0       	ldi	r26, 0x00	; 0
 264:	b0 e0       	ldi	r27, 0x00	; 0
 266:	80 93 05 01 	sts	0x0105, r24
 26a:	90 93 06 01 	sts	0x0106, r25
 26e:	a0 93 07 01 	sts	0x0107, r26
 272:	b0 93 08 01 	sts	0x0108, r27
 276:	13 c0       	rjmp	.+38     	; 0x29e <change_duty+0x5a>
	}
	else {
		duty += 10;
 278:	80 91 05 01 	lds	r24, 0x0105
 27c:	90 91 06 01 	lds	r25, 0x0106
 280:	a0 91 07 01 	lds	r26, 0x0107
 284:	b0 91 08 01 	lds	r27, 0x0108
 288:	0a 96       	adiw	r24, 0x0a	; 10
 28a:	a1 1d       	adc	r26, r1
 28c:	b1 1d       	adc	r27, r1
 28e:	80 93 05 01 	sts	0x0105, r24
 292:	90 93 06 01 	sts	0x0106, r25
 296:	a0 93 07 01 	sts	0x0107, r26
 29a:	b0 93 08 01 	sts	0x0108, r27
	}
	set_wave();
 29e:	0e 94 b4 00 	call	0x168	; 0x168 <set_wave>
}
 2a2:	08 95       	ret

000002a4 <change_frequency>:
	}
	set_wave();
}

void change_frequency(void) {
	if (freq == 500) {
 2a4:	80 91 01 01 	lds	r24, 0x0101
 2a8:	90 91 02 01 	lds	r25, 0x0102
 2ac:	a0 91 03 01 	lds	r26, 0x0103
 2b0:	b0 91 04 01 	lds	r27, 0x0104
 2b4:	84 3f       	cpi	r24, 0xF4	; 244
 2b6:	21 e0       	ldi	r18, 0x01	; 1
 2b8:	92 07       	cpc	r25, r18
 2ba:	20 e0       	ldi	r18, 0x00	; 0
 2bc:	a2 07       	cpc	r26, r18
 2be:	20 e0       	ldi	r18, 0x00	; 0
 2c0:	b2 07       	cpc	r27, r18
 2c2:	69 f4       	brne	.+26     	; 0x2de <change_frequency+0x3a>
		freq = 100;
 2c4:	84 e6       	ldi	r24, 0x64	; 100
 2c6:	90 e0       	ldi	r25, 0x00	; 0
 2c8:	a0 e0       	ldi	r26, 0x00	; 0
 2ca:	b0 e0       	ldi	r27, 0x00	; 0
 2cc:	80 93 01 01 	sts	0x0101, r24
 2d0:	90 93 02 01 	sts	0x0102, r25
 2d4:	a0 93 03 01 	sts	0x0103, r26
 2d8:	b0 93 04 01 	sts	0x0104, r27
 2dc:	14 c0       	rjmp	.+40     	; 0x306 <change_frequency+0x62>
	}
	else {
		freq += 100;
 2de:	80 91 01 01 	lds	r24, 0x0101
 2e2:	90 91 02 01 	lds	r25, 0x0102
 2e6:	a0 91 03 01 	lds	r26, 0x0103
 2ea:	b0 91 04 01 	lds	r27, 0x0104
 2ee:	8c 59       	subi	r24, 0x9C	; 156
 2f0:	9f 4f       	sbci	r25, 0xFF	; 255
 2f2:	af 4f       	sbci	r26, 0xFF	; 255
 2f4:	bf 4f       	sbci	r27, 0xFF	; 255
 2f6:	80 93 01 01 	sts	0x0101, r24
 2fa:	90 93 02 01 	sts	0x0102, r25
 2fe:	a0 93 03 01 	sts	0x0103, r26
 302:	b0 93 04 01 	sts	0x0104, r27
	}
	set_wave();
 306:	0e 94 b4 00 	call	0x168	; 0x168 <set_wave>
}
 30a:	08 95       	ret

0000030c <change_wave_type>:
	}
}

void change_wave_type() {

	if (fg_state == SQUARE) {
 30c:	80 91 00 01 	lds	r24, 0x0100
 310:	88 23       	and	r24, r24
 312:	41 f4       	brne	.+16     	; 0x324 <change_wave_type+0x18>
		timer1_off();
 314:	0e 94 9b 00 	call	0x136	; 0x136 <timer1_off>
		fg_state = SAWTOOTH;
 318:	81 e0       	ldi	r24, 0x01	; 1
 31a:	80 93 00 01 	sts	0x0100, r24
		timer3_on();
 31e:	0e 94 a3 00 	call	0x146	; 0x146 <timer3_on>
 322:	16 c0       	rjmp	.+44     	; 0x350 <change_wave_type+0x44>
	}		
	else if (fg_state == SAWTOOTH) {
 324:	80 91 00 01 	lds	r24, 0x0100
 328:	81 30       	cpi	r24, 0x01	; 1
 32a:	21 f4       	brne	.+8      	; 0x334 <change_wave_type+0x28>
		fg_state = SINE;
 32c:	82 e0       	ldi	r24, 0x02	; 2
 32e:	80 93 00 01 	sts	0x0100, r24
 332:	0e c0       	rjmp	.+28     	; 0x350 <change_wave_type+0x44>
	}
	else if (fg_state == SINE) {
 334:	80 91 00 01 	lds	r24, 0x0100
 338:	82 30       	cpi	r24, 0x02	; 2
 33a:	39 f4       	brne	.+14     	; 0x34a <change_wave_type+0x3e>
		timer3_off();
 33c:	0e 94 ac 00 	call	0x158	; 0x158 <timer3_off>
		fg_state = SQUARE;
 340:	10 92 00 01 	sts	0x0100, r1
		timer1_on();
 344:	0e 94 92 00 	call	0x124	; 0x124 <timer1_on>
 348:	03 c0       	rjmp	.+6      	; 0x350 <change_wave_type+0x44>
	} else {
		fg_state = SINE;
 34a:	82 e0       	ldi	r24, 0x02	; 2
 34c:	80 93 00 01 	sts	0x0100, r24
	}
	set_wave();
 350:	0e 94 b4 00 	call	0x168	; 0x168 <set_wave>
}
 354:	08 95       	ret

00000356 <pollButtons>:
}

void pollButtons(void) {
	int i;
	
	if (!(PIND & 1<<WAVE_TYPE_BTN)) { 
 356:	48 99       	sbic	0x09, 0	; 9
 358:	0b c0       	rjmp	.+22     	; 0x370 <pollButtons+0x1a>
		change_wave_type();
 35a:	0e 94 86 01 	call	0x30c	; 0x30c <change_wave_type>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 35e:	8f ef       	ldi	r24, 0xFF	; 255
 360:	91 ee       	ldi	r25, 0xE1	; 225
 362:	a4 e0       	ldi	r26, 0x04	; 4
 364:	81 50       	subi	r24, 0x01	; 1
 366:	90 40       	sbci	r25, 0x00	; 0
 368:	a0 40       	sbci	r26, 0x00	; 0
 36a:	e1 f7       	brne	.-8      	; 0x364 <pollButtons+0xe>
 36c:	00 c0       	rjmp	.+0      	; 0x36e <pollButtons+0x18>
 36e:	00 00       	nop
		_delay_ms(100);
	}
	if (!(PINF & 1<<DUTY_CYCLE_BTN)) {
 370:	7c 99       	sbic	0x0f, 4	; 15
 372:	0b c0       	rjmp	.+22     	; 0x38a <pollButtons+0x34>
		change_duty();
 374:	0e 94 22 01 	call	0x244	; 0x244 <change_duty>
 378:	8f ef       	ldi	r24, 0xFF	; 255
 37a:	91 ee       	ldi	r25, 0xE1	; 225
 37c:	a4 e0       	ldi	r26, 0x04	; 4
 37e:	81 50       	subi	r24, 0x01	; 1
 380:	90 40       	sbci	r25, 0x00	; 0
 382:	a0 40       	sbci	r26, 0x00	; 0
 384:	e1 f7       	brne	.-8      	; 0x37e <pollButtons+0x28>
 386:	00 c0       	rjmp	.+0      	; 0x388 <pollButtons+0x32>
 388:	00 00       	nop
		_delay_ms(100);
	}
	if (!(PIND & 1<<FREQ_VAL_BTN)) {
 38a:	49 99       	sbic	0x09, 1	; 9
 38c:	0b c0       	rjmp	.+22     	; 0x3a4 <pollButtons+0x4e>
		change_frequency();
 38e:	0e 94 52 01 	call	0x2a4	; 0x2a4 <change_frequency>
 392:	8f ef       	ldi	r24, 0xFF	; 255
 394:	91 ee       	ldi	r25, 0xE1	; 225
 396:	a4 e0       	ldi	r26, 0x04	; 4
 398:	81 50       	subi	r24, 0x01	; 1
 39a:	90 40       	sbci	r25, 0x00	; 0
 39c:	a0 40       	sbci	r26, 0x00	; 0
 39e:	e1 f7       	brne	.-8      	; 0x398 <pollButtons+0x42>
 3a0:	00 c0       	rjmp	.+0      	; 0x3a2 <pollButtons+0x4c>
 3a2:	00 00       	nop
 3a4:	08 95       	ret

000003a6 <set_DAC_data>:
		OCR3AL = sin_ticks_per_step & 0xFF;		
	}
}

void set_DAC_data(uint16_t data) {
	spi_msb = (data >> 8 & 0xF) | 0x70;
 3a6:	9f 70       	andi	r25, 0x0F	; 15
 3a8:	90 67       	ori	r25, 0x70	; 112
 3aa:	90 93 8b 01 	sts	0x018B, r25
	spi_lsb = data & 0xFF;
 3ae:	80 93 8a 01 	sts	0x018A, r24
}
 3b2:	08 95       	ret

000003b4 <Initialize_SPI_Master>:

void Initialize_SPI_Master(void)
{
	SPCR = (1<<SPIE) | 		//No interrupts
 3b4:	80 ed       	ldi	r24, 0xD0	; 208
 3b6:	8c bd       	out	0x2c, r24	; 44
	(1<<MSTR) | 			//master
	(0<<CPOL) | 			//clock idles low
	(0<<CPHA) | 			//sample falling clock edge
	(0<<SPR1) | (0<<SPR0) ; //clock speed
	
	SPSR = (0<<SPIF) | 		//SPI interrupt flag
 3b8:	81 e0       	ldi	r24, 0x01	; 1
 3ba:	8d bd       	out	0x2d, r24	; 45
	(0<<WCOL) | 			//Write collision flag
	(1<<SPI2X) ; 			//Doubles SPI clock
	PORTB = 1 << SS;  		// make sure SS is high
 3bc:	85 b9       	out	0x05, r24	; 5
}
 3be:	08 95       	ret

000003c0 <main>:
void initButtons(void);
void pollButtons(void);

int main(void)
{	
	initButtons();
 3c0:	0e 94 75 00 	call	0xea	; 0xea <initButtons>
	initTimer1(); // timer for square
 3c4:	0e 94 7e 00 	call	0xfc	; 0xfc <initTimer1>
	initTimer3(); // timer for sine/sawtooth
 3c8:	0e 94 88 00 	call	0x110	; 0x110 <initTimer3>
	set_wave();
 3cc:	0e 94 b4 00 	call	0x168	; 0x168 <set_wave>
	
	timer3_on();
 3d0:	0e 94 a3 00 	call	0x146	; 0x146 <timer3_on>
	sei();
 3d4:	78 94       	sei
	
	DDRB = 1<<MOSI | 1<<SCK | 1<<SS;	// make MOSI, SCK and SS outputs
 3d6:	87 e0       	ldi	r24, 0x07	; 7
 3d8:	84 b9       	out	0x04, r24	; 4
	Initialize_SPI_Master();
 3da:	0e 94 da 01 	call	0x3b4	; 0x3b4 <Initialize_SPI_Master>
	
	while(1) {
		pollButtons();
 3de:	0e 94 ab 01 	call	0x356	; 0x356 <pollButtons>
 3e2:	fd cf       	rjmp	.-6      	; 0x3de <main+0x1e>

000003e4 <Transmit_SPI_Master>:
	PORTB = 1 << SS;  		// make sure SS is high
}

void Transmit_SPI_Master(void) {
	
	if (spi_state == XFER_FINISHED) {
 3e4:	80 91 8c 01 	lds	r24, 0x018C
 3e8:	88 23       	and	r24, r24
 3ea:	41 f4       	brne	.+16     	; 0x3fc <Transmit_SPI_Master+0x18>
		spi_state = MSB_SENT;
 3ec:	81 e0       	ldi	r24, 0x01	; 1
 3ee:	80 93 8c 01 	sts	0x018C, r24
		PORTB &= ~(1 << SS); 		  //Assert slave select (active low) 		
 3f2:	28 98       	cbi	0x05, 0	; 5
		SPDR = spi_msb;
 3f4:	80 91 8b 01 	lds	r24, 0x018B
 3f8:	8e bd       	out	0x2e, r24	; 46
 3fa:	08 95       	ret
	}
	else if (spi_state == MSB_SENT) {
 3fc:	80 91 8c 01 	lds	r24, 0x018C
 400:	81 30       	cpi	r24, 0x01	; 1
 402:	39 f4       	brne	.+14     	; 0x412 <Transmit_SPI_Master+0x2e>
		spi_state = LSB_SENT;
 404:	82 e0       	ldi	r24, 0x02	; 2
 406:	80 93 8c 01 	sts	0x018C, r24
		SPDR = spi_lsb;
 40a:	80 91 8a 01 	lds	r24, 0x018A
 40e:	8e bd       	out	0x2e, r24	; 46
 410:	08 95       	ret
	}
	else {
		spi_state = XFER_FINISHED;
 412:	10 92 8c 01 	sts	0x018C, r1
		PORTB |= 1 << SS;
 416:	28 9a       	sbi	0x05, 0	; 5
 418:	08 95       	ret

0000041a <__vector_24>:
	}
}

ISR(SPI_STC_vect) {
 41a:	1f 92       	push	r1
 41c:	0f 92       	push	r0
 41e:	0f b6       	in	r0, 0x3f	; 63
 420:	0f 92       	push	r0
 422:	11 24       	eor	r1, r1
 424:	2f 93       	push	r18
 426:	3f 93       	push	r19
 428:	4f 93       	push	r20
 42a:	5f 93       	push	r21
 42c:	6f 93       	push	r22
 42e:	7f 93       	push	r23
 430:	8f 93       	push	r24
 432:	9f 93       	push	r25
 434:	af 93       	push	r26
 436:	bf 93       	push	r27
 438:	ef 93       	push	r30
 43a:	ff 93       	push	r31
	cli();
 43c:	f8 94       	cli
	Transmit_SPI_Master();
 43e:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <Transmit_SPI_Master>
	sei();
 442:	78 94       	sei
}
 444:	ff 91       	pop	r31
 446:	ef 91       	pop	r30
 448:	bf 91       	pop	r27
 44a:	af 91       	pop	r26
 44c:	9f 91       	pop	r25
 44e:	8f 91       	pop	r24
 450:	7f 91       	pop	r23
 452:	6f 91       	pop	r22
 454:	5f 91       	pop	r21
 456:	4f 91       	pop	r20
 458:	3f 91       	pop	r19
 45a:	2f 91       	pop	r18
 45c:	0f 90       	pop	r0
 45e:	0f be       	out	0x3f, r0	; 63
 460:	0f 90       	pop	r0
 462:	1f 90       	pop	r1
 464:	18 95       	reti

00000466 <__vector_17>:

ISR(TIMER1_COMPA_vect) {
 466:	1f 92       	push	r1
 468:	0f 92       	push	r0
 46a:	0f b6       	in	r0, 0x3f	; 63
 46c:	0f 92       	push	r0
 46e:	11 24       	eor	r1, r1
 470:	2f 93       	push	r18
 472:	3f 93       	push	r19
 474:	4f 93       	push	r20
 476:	5f 93       	push	r21
 478:	6f 93       	push	r22
 47a:	7f 93       	push	r23
 47c:	8f 93       	push	r24
 47e:	9f 93       	push	r25
 480:	af 93       	push	r26
 482:	bf 93       	push	r27
 484:	ef 93       	push	r30
 486:	ff 93       	push	r31
	set_DAC_data(0xFFF);
 488:	8f ef       	ldi	r24, 0xFF	; 255
 48a:	9f e0       	ldi	r25, 0x0F	; 15
 48c:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <set_DAC_data>
	Transmit_SPI_Master();
 490:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <Transmit_SPI_Master>
}
 494:	ff 91       	pop	r31
 496:	ef 91       	pop	r30
 498:	bf 91       	pop	r27
 49a:	af 91       	pop	r26
 49c:	9f 91       	pop	r25
 49e:	8f 91       	pop	r24
 4a0:	7f 91       	pop	r23
 4a2:	6f 91       	pop	r22
 4a4:	5f 91       	pop	r21
 4a6:	4f 91       	pop	r20
 4a8:	3f 91       	pop	r19
 4aa:	2f 91       	pop	r18
 4ac:	0f 90       	pop	r0
 4ae:	0f be       	out	0x3f, r0	; 63
 4b0:	0f 90       	pop	r0
 4b2:	1f 90       	pop	r1
 4b4:	18 95       	reti

000004b6 <__vector_18>:

ISR(TIMER1_COMPB_vect) {
 4b6:	1f 92       	push	r1
 4b8:	0f 92       	push	r0
 4ba:	0f b6       	in	r0, 0x3f	; 63
 4bc:	0f 92       	push	r0
 4be:	11 24       	eor	r1, r1
 4c0:	2f 93       	push	r18
 4c2:	3f 93       	push	r19
 4c4:	4f 93       	push	r20
 4c6:	5f 93       	push	r21
 4c8:	6f 93       	push	r22
 4ca:	7f 93       	push	r23
 4cc:	8f 93       	push	r24
 4ce:	9f 93       	push	r25
 4d0:	af 93       	push	r26
 4d2:	bf 93       	push	r27
 4d4:	ef 93       	push	r30
 4d6:	ff 93       	push	r31
	set_DAC_data(0);
 4d8:	80 e0       	ldi	r24, 0x00	; 0
 4da:	90 e0       	ldi	r25, 0x00	; 0
 4dc:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <set_DAC_data>
	Transmit_SPI_Master();
 4e0:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <Transmit_SPI_Master>
}
 4e4:	ff 91       	pop	r31
 4e6:	ef 91       	pop	r30
 4e8:	bf 91       	pop	r27
 4ea:	af 91       	pop	r26
 4ec:	9f 91       	pop	r25
 4ee:	8f 91       	pop	r24
 4f0:	7f 91       	pop	r23
 4f2:	6f 91       	pop	r22
 4f4:	5f 91       	pop	r21
 4f6:	4f 91       	pop	r20
 4f8:	3f 91       	pop	r19
 4fa:	2f 91       	pop	r18
 4fc:	0f 90       	pop	r0
 4fe:	0f be       	out	0x3f, r0	; 63
 500:	0f 90       	pop	r0
 502:	1f 90       	pop	r1
 504:	18 95       	reti

00000506 <__vector_32>:

ISR(TIMER3_COMPA_vect) {
 506:	1f 92       	push	r1
 508:	0f 92       	push	r0
 50a:	0f b6       	in	r0, 0x3f	; 63
 50c:	0f 92       	push	r0
 50e:	11 24       	eor	r1, r1
 510:	2f 93       	push	r18
 512:	3f 93       	push	r19
 514:	4f 93       	push	r20
 516:	5f 93       	push	r21
 518:	6f 93       	push	r22
 51a:	7f 93       	push	r23
 51c:	8f 93       	push	r24
 51e:	9f 93       	push	r25
 520:	af 93       	push	r26
 522:	bf 93       	push	r27
 524:	ef 93       	push	r30
 526:	ff 93       	push	r31
	uint16_t dac_val = 0;
	
	if (fg_state == SAWTOOTH) {	
 528:	80 91 00 01 	lds	r24, 0x0100
 52c:	81 30       	cpi	r24, 0x01	; 1
 52e:	11 f5       	brne	.+68     	; 0x574 <__vector_32+0x6e>
		static uint16_t saw_val = 0;
		
		if (saw_val == 0xFFF)
 530:	80 91 8d 01 	lds	r24, 0x018D
 534:	90 91 8e 01 	lds	r25, 0x018E
 538:	2f e0       	ldi	r18, 0x0F	; 15
 53a:	8f 3f       	cpi	r24, 0xFF	; 255
 53c:	92 07       	cpc	r25, r18
 53e:	29 f4       	brne	.+10     	; 0x54a <__vector_32+0x44>
			saw_val = 0;
 540:	10 92 8e 01 	sts	0x018E, r1
 544:	10 92 8d 01 	sts	0x018D, r1
 548:	10 c0       	rjmp	.+32     	; 0x56a <__vector_32+0x64>
		else
			saw_val += 4096 / NUM_SAW_POINTS;
 54a:	80 5c       	subi	r24, 0xC0	; 192
 54c:	9f 4f       	sbci	r25, 0xFF	; 255
 54e:	90 93 8e 01 	sts	0x018E, r25
 552:	80 93 8d 01 	sts	0x018D, r24
	
		if (saw_val >= 0x1000) // dac can only take in 0xFFF and lower
 556:	20 e1       	ldi	r18, 0x10	; 16
 558:	80 30       	cpi	r24, 0x00	; 0
 55a:	92 07       	cpc	r25, r18
 55c:	30 f0       	brcs	.+12     	; 0x56a <__vector_32+0x64>
			saw_val = 0xFFF;
 55e:	8f ef       	ldi	r24, 0xFF	; 255
 560:	9f e0       	ldi	r25, 0x0F	; 15
 562:	90 93 8e 01 	sts	0x018E, r25
 566:	80 93 8d 01 	sts	0x018D, r24
		
		dac_val = saw_val;
 56a:	80 91 8d 01 	lds	r24, 0x018D
 56e:	90 91 8e 01 	lds	r25, 0x018E
 572:	23 c0       	rjmp	.+70     	; 0x5ba <__vector_32+0xb4>
	}
	else if (fg_state == SINE) {
 574:	80 91 00 01 	lds	r24, 0x0100
 578:	82 30       	cpi	r24, 0x02	; 2
 57a:	e9 f4       	brne	.+58     	; 0x5b6 <__vector_32+0xb0>
		static uint16_t sine_cnt = 0;
		
		if (sine_cnt == NUM_SINE_POINTS) {
 57c:	80 91 8f 01 	lds	r24, 0x018F
 580:	90 91 90 01 	lds	r25, 0x0190
 584:	80 34       	cpi	r24, 0x40	; 64
 586:	91 05       	cpc	r25, r1
 588:	21 f4       	brne	.+8      	; 0x592 <__vector_32+0x8c>
			sine_cnt = 0;
 58a:	10 92 90 01 	sts	0x0190, r1
 58e:	10 92 8f 01 	sts	0x018F, r1
		}			
		
		dac_val = SINE_VALS[sine_cnt];
 592:	20 91 8f 01 	lds	r18, 0x018F
 596:	30 91 90 01 	lds	r19, 0x0190
 59a:	f9 01       	movw	r30, r18
 59c:	ee 0f       	add	r30, r30
 59e:	ff 1f       	adc	r31, r31
 5a0:	e7 5f       	subi	r30, 0xF7	; 247
 5a2:	fe 4f       	sbci	r31, 0xFE	; 254
 5a4:	80 81       	ld	r24, Z
 5a6:	91 81       	ldd	r25, Z+1	; 0x01
		sine_cnt ++;
 5a8:	2f 5f       	subi	r18, 0xFF	; 255
 5aa:	3f 4f       	sbci	r19, 0xFF	; 255
 5ac:	30 93 90 01 	sts	0x0190, r19
 5b0:	20 93 8f 01 	sts	0x018F, r18
 5b4:	02 c0       	rjmp	.+4      	; 0x5ba <__vector_32+0xb4>
	set_DAC_data(0);
	Transmit_SPI_Master();
}

ISR(TIMER3_COMPA_vect) {
	uint16_t dac_val = 0;
 5b6:	80 e0       	ldi	r24, 0x00	; 0
 5b8:	90 e0       	ldi	r25, 0x00	; 0
		
		dac_val = SINE_VALS[sine_cnt];
		sine_cnt ++;
	}		
				
	set_DAC_data(dac_val);
 5ba:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <set_DAC_data>
	Transmit_SPI_Master();
 5be:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <Transmit_SPI_Master>
}
 5c2:	ff 91       	pop	r31
 5c4:	ef 91       	pop	r30
 5c6:	bf 91       	pop	r27
 5c8:	af 91       	pop	r26
 5ca:	9f 91       	pop	r25
 5cc:	8f 91       	pop	r24
 5ce:	7f 91       	pop	r23
 5d0:	6f 91       	pop	r22
 5d2:	5f 91       	pop	r21
 5d4:	4f 91       	pop	r20
 5d6:	3f 91       	pop	r19
 5d8:	2f 91       	pop	r18
 5da:	0f 90       	pop	r0
 5dc:	0f be       	out	0x3f, r0	; 63
 5de:	0f 90       	pop	r0
 5e0:	1f 90       	pop	r1
 5e2:	18 95       	reti

000005e4 <__mulsi3>:
 5e4:	62 9f       	mul	r22, r18
 5e6:	d0 01       	movw	r26, r0
 5e8:	73 9f       	mul	r23, r19
 5ea:	f0 01       	movw	r30, r0
 5ec:	82 9f       	mul	r24, r18
 5ee:	e0 0d       	add	r30, r0
 5f0:	f1 1d       	adc	r31, r1
 5f2:	64 9f       	mul	r22, r20
 5f4:	e0 0d       	add	r30, r0
 5f6:	f1 1d       	adc	r31, r1
 5f8:	92 9f       	mul	r25, r18
 5fa:	f0 0d       	add	r31, r0
 5fc:	83 9f       	mul	r24, r19
 5fe:	f0 0d       	add	r31, r0
 600:	74 9f       	mul	r23, r20
 602:	f0 0d       	add	r31, r0
 604:	65 9f       	mul	r22, r21
 606:	f0 0d       	add	r31, r0
 608:	99 27       	eor	r25, r25
 60a:	72 9f       	mul	r23, r18
 60c:	b0 0d       	add	r27, r0
 60e:	e1 1d       	adc	r30, r1
 610:	f9 1f       	adc	r31, r25
 612:	63 9f       	mul	r22, r19
 614:	b0 0d       	add	r27, r0
 616:	e1 1d       	adc	r30, r1
 618:	f9 1f       	adc	r31, r25
 61a:	bd 01       	movw	r22, r26
 61c:	cf 01       	movw	r24, r30
 61e:	11 24       	eor	r1, r1
 620:	08 95       	ret

00000622 <__udivmodsi4>:
 622:	a1 e2       	ldi	r26, 0x21	; 33
 624:	1a 2e       	mov	r1, r26
 626:	aa 1b       	sub	r26, r26
 628:	bb 1b       	sub	r27, r27
 62a:	fd 01       	movw	r30, r26
 62c:	0d c0       	rjmp	.+26     	; 0x648 <__udivmodsi4_ep>

0000062e <__udivmodsi4_loop>:
 62e:	aa 1f       	adc	r26, r26
 630:	bb 1f       	adc	r27, r27
 632:	ee 1f       	adc	r30, r30
 634:	ff 1f       	adc	r31, r31
 636:	a2 17       	cp	r26, r18
 638:	b3 07       	cpc	r27, r19
 63a:	e4 07       	cpc	r30, r20
 63c:	f5 07       	cpc	r31, r21
 63e:	20 f0       	brcs	.+8      	; 0x648 <__udivmodsi4_ep>
 640:	a2 1b       	sub	r26, r18
 642:	b3 0b       	sbc	r27, r19
 644:	e4 0b       	sbc	r30, r20
 646:	f5 0b       	sbc	r31, r21

00000648 <__udivmodsi4_ep>:
 648:	66 1f       	adc	r22, r22
 64a:	77 1f       	adc	r23, r23
 64c:	88 1f       	adc	r24, r24
 64e:	99 1f       	adc	r25, r25
 650:	1a 94       	dec	r1
 652:	69 f7       	brne	.-38     	; 0x62e <__udivmodsi4_loop>
 654:	60 95       	com	r22
 656:	70 95       	com	r23
 658:	80 95       	com	r24
 65a:	90 95       	com	r25
 65c:	9b 01       	movw	r18, r22
 65e:	ac 01       	movw	r20, r24
 660:	bd 01       	movw	r22, r26
 662:	cf 01       	movw	r24, r30
 664:	08 95       	ret

00000666 <_exit>:
 666:	f8 94       	cli

00000668 <__stop_program>:
 668:	ff cf       	rjmp	.-2      	; 0x668 <__stop_program>
